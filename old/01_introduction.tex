It is obvious that building sector has witnessed massive development recently in the way by which building systems are managed in order to alleviate the massive energy consumption of this sector by better controlling the resources; providing sustainable and more efficient solutions; developing a better understanding of microclimate, buildings, and users' behaviours; and making better decisions based on either insightful ground-truth data (black-box approach), physics-based simulation models (white box approach) or a mixture of them (gray box approach). In this regard, it is worth mentioning that building sector is responsible for 30\% of the world energy consumption and a third of the associated CO2 emissions \citet{Iea2013TrackingMinisterial}.

On the other hand, the emergence of the micro-electro mechanical devices (MEMS) which lead to the ubiquitness of Internet-of-Things (IoT) devices (mobile devices, sensors, wearables, actuators ..etc) in the last few years to the extent that the number of interconnected IoT devices reached 11.2 billion by the time of writing this paper and continuing growing exponentially. These devices drastically changed computing paradigms, sensing and monitoring \citet{Ramaswamy2015InternetReview}, which enabled massive flow of data from each aspect of life such that the data collected during the last two decades exceeded that which is collected from the beginning of history. The biggest challenge ,though, is not the availability of data itself, but rather managing this big data: transferring, storing, preprocessing, wrangling and mining to obtain knowledge, optimization and control in a robust cyberinfrastructure. This lead to cloud computing or ubiquitous computing, that is , computing data in place, without paying much effort in transferring data to local storage/processing machines using scalable storage and computational power on demand maintained by professionals and provided in a form of Infrastructure as a Service (IaaS) and Platform as a service (PaaS) \cite{MellTheTechnology,Bhardwaj2010CLOUDIAAS,Dillon2010CloudChallenges}.

The convergence of those technologies however, requires users with proper domain knowledge alongside with programming or procedural thinking skills for automating, prototyping, analyzing, building work-flows using the massive amount of data and IoT sensors. Thus the term End-use programmer first introduced by \citet{Nardi1993AComputing} or Novice developer is used to describe people who are not professional developers yet able to create/modify software without significant knowledge of programming language and code structures \cite{MARGARETM.BURNETTANDCHRISTOPHERSCAFFIDIEnd-UserEd.}. In fact, most programs today are written by novice programmers \citet{Rothermel2011TheEngineering} as it had been estimated that by 2012, there would be less than 3 million professional programmers compared to more than 55 million end-use programmers, using spreadsheets, writing add-ons/plugins to support their work or add functionality to a software, running Matlab simulations, writing python codes, or IPython notebooks and so on \citet{ScaffidiEstimatingProgrammers}. The main difference between the end-use developer and the professional developer is the goal of the development. The former writes program to do specific task with the focus on getting this task done without paying so much attention to debugging, unit-testing or re-usability. however the latter develops, maintain, debug, and test a robust software for others to use. However they both face common challenges such as choosing which APIs, libraries, and functions to use; in addition, testing, verifying and debugging their codes regardless of the programming language used and its degree of complexity, for example: an end-use programmer could use general purpose language such as C++ to achieve specific task without the intent to publish the code for other to use. On the other side, a professional programmer could use a simple markup language such as HTML/CSS to develop a commercial website.

Each programming has what is so called a programming notation, this notation could be textual, diagrammatic, gesture-based .. etc. which is used to represent the state of the world. The selection of the proper programming notation to describe the problem is a trade-off between a number criteria that are based on cognitive psychology introduced by \citet{Green2004InstructionsDescriptions}, These are: \textbf{1)Viscosity (resistance to change)}, for example, if we need to change the interval time granularity of all sensors simultanously, how resistant would be the code? \textbf{2)Visibility (ability to view components easily)}, i.e. information are not hidden in encapsulations. \textbf{3)Premature commitment (constraints on the order of doing things)}, for example, the need to declare variable types or allocate memory initially. \textbf{4) Hidden dependencies (important links between entities are not visible)}, for instance, if there are interconnected entities, where the change one's value would affect the others, how visible is this interconnection? 

\subsection{visual programming}

%There has been much research done on visual programming languages (VPLs) and en-vironments (VPEs). This has resulted in several different paradigms and styles of visual programming. We can classify VPLs based on their programming paradigm. Some of the most important VPL paradigms are constraint-based VPLs, data-flow VPLs, form-based and spreadsheet-based VPLs, imperative VPLs, and rule-based VPLs (Burnett & Baker, 1994). Costagolia et al. (2002) categorize VPLs based on the type of graphical notation they use. The Graph class of VPLs are those that consist of boxes and arrows connecting them. The Plex class covers the ones with flowchart style graphs with objects that have predefined number of attaching points. The Box class is mostly used for geographical sys- tems and consists of boxes that represent objects and spatial rules such as inclusion and intersection that represent queries. The Iconic class of VPLs uses icons for objects. And finally the Hybrid class uses features of two or more of above classes.
%needs rephrasing: 
Data-flow visual programming languages (DFVPLs)
Data-flow languages had been around for a while but the availability of cheap graphical
hardware in 1990s caused advances in data-flow visual language design (Johnston et al., 2004).